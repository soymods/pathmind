name: Release to Discord

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Release tag to announce when running manually (e.g. 1.0.2). Leave blank to use the selected ref name."
        required: false
        type: string
      mention_here:
        description: "Ping @here"
        required: false
        type: boolean
        default: true

jobs:
  build-and-post:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "21"
          cache: gradle

      - name: Grant execute permission for Gradle
        run: chmod +x ./gradlew

      - name: Download Baritone API dependency
        run: |
          set -euo pipefail
          mkdir -p libs
          curl --fail -L -o libs/baritone-api-fabric-1.15.0.jar \
            https://github.com/cabaletta/baritone/releases/download/v1.15.0/baritone-api-fabric-1.15.0.jar
          ls -l libs/baritone-api-fabric-1.15.0.jar

      - name: Build
        env:
          BARITONE_API_JAR: libs/baritone-api-fabric-1.15.0.jar
        run: |
          set -euo pipefail
          test -f libs/baritone-api-fabric-1.15.0.jar
          ./gradlew build -PbaritoneApiPath=libs/baritone-api-fabric-1.15.0.jar

      - name: Post to Discord (message + all jar attachments)
        shell: bash
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          INPUT_RELEASE_TAG: ${{ inputs.release_tag }}
          INPUT_MENTION_HERE: ${{ inputs.mention_here }}
        run: |
          set -euo pipefail

          NAME="${{ github.event.repository.name }}"

          # Prefer real release payload when triggered by a published release
          TAG="${{ github.event.release.tag_name }}"
          URL="${{ github.event.release.html_url }}"

          # If manual run, use provided input or the selected ref name
          if [ -z "${TAG}" ] || [ "${TAG}" = "null" ]; then
            if [ -n "${INPUT_RELEASE_TAG}" ]; then
              TAG="${INPUT_RELEASE_TAG}"
            else
              TAG="${GITHUB_REF_NAME}"
            fi
          fi

          # Build a URL if the release payload isn't present (manual runs)
          if [ -z "${URL}" ] || [ "${URL}" = "null" ]; then
            URL="https://github.com/${GITHUB_REPOSITORY}/releases/tag/${TAG}"
          fi

          # Mention line (optional)
          MENTION=""
          if [ "${INPUT_MENTION_HERE}" = "true" ]; then
            MENTION='@here\n'
          fi

          # Collect all "main" jars (ignore common extra jars)
          mapfile -t JARS < <(ls -1 build/libs/*.jar 2>/dev/null \
            | grep -Ev '(-sources|-javadoc|-dev|-shadow|-all)\.jar$' || true)

          if [ "${#JARS[@]}" -eq 0 ]; then
            echo "No suitable jars found in build/libs/"
            ls -la build/libs || true
            exit 1
          fi

          # Build curl args for multiple attachments: file1, file2, file3...
          CURL_FILES=()
          i=1
          for jar in "${JARS[@]}"; do
            echo "Attaching: $jar"
            CURL_FILES+=(-F "file${i}=@${jar}")
            i=$((i+1))
          done

          # Build a nice downloads list for the message body (string with newlines)
          DOWNLOAD_LIST=""
          for jar in "${JARS[@]}"; do
            DOWNLOAD_LIST="${DOWNLOAD_LIST}â€¢ $(basename "$jar")\n"
          done

          # Send message + attachments
          curl \
            -F "payload_json={\"content\":\"${MENTION}**${NAME} ${TAG}**\n\nGitHub Release:\n${URL}\n\nDownloads:\n${DOWNLOAD_LIST}\"}" \
            "${CURL_FILES[@]}" \
            "${DISCORD_WEBHOOK_URL}"
